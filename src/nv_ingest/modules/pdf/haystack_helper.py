# Copyright (c) 2024, NVIDIA CORPORATION.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import io
import logging
import warnings
from concurrent.futures import ProcessPoolExecutor
from multiprocessing import cpu_count
from typing import Any, Dict, List, Literal, Optional, Union

import fitz
from haystack.nodes import PDFToTextConverter, PreProcessor
from haystack.schema import Document
from more_itertools import divide

logger = logging.getLogger(__name__)


class PDFtoTextConverterStream(PDFToTextConverter):
    def convert(
        self,
        stream: io.BytesIO,
        meta: Optional[Dict[str, Any]] = None,
        remove_numeric_tables: Optional[bool] = None,
        valid_languages: Optional[List[str]] = None,
        encoding: Optional[str] = None,
        id_hash_keys: Optional[List[str]] = None,
        start_page: Optional[int] = None,
        end_page: Optional[int] = None,
        keep_physical_layout: Optional[bool] = None,
        sort_by_position: Optional[bool] = None,
        ocr: Optional[Literal["auto", "full"]] = None,
        ocr_language: Optional[str] = None,
        multiprocessing: Optional[Union[bool, int]] = None,
    ) -> List[Document]:
        """
        Extract text from a PDF file and convert it to a Document.

        Parameters
        ----------
        stream : io.BytesIO
            Bytestream of pdf to convert.
        meta : Optional[Dict[str, Any]]
            Optional dictionary with metadata that shall be attached to all resulting documents.
            Can be any custom keys and values.
        remove_numeric_tables : Optional[bool]
            This option uses heuristics to remove numeric rows from the tables.
            The tabular structures in documents might be noise for the reader model if it
            does not have table parsing capability for finding answers. However, tables
            may also have long strings that could possible candidate for searching answers.
            The rows containing strings are thus retained in this option.
        valid_languages : Optional[List[str]]
            validate languages from a list of languages specified in the ISO 639-1
            (https://en.wikipedia.org/wiki/ISO_639-1) format.
            This option can be used to add test for encoding errors. If the extracted text is
            not one of the valid languages, then it might likely be encoding error resulting
            in garbled text.
        encoding : Optional[str]
            This parameter is being deprecated.
            It will be automatically detected by PyMuPDF.
        id_hash_keys : Optional[List[str]]
            Generate the document id from a custom list of strings that refer to the document's
            attributes. If you want to ensure you don't have duplicate documents in your
            DocumentStore but texts are not unique, you can modify the metadata and pass e.g.
            `"meta"` to this field (e.g. [`"content"`, `"meta"`]).  In this case the id will be
            generated by using the content and the defined metadata.
        start_page : Optional[int]
            The page number where to start the conversion
        end_page : Optional[int]
            The page number where to end the conversion.
        keep_physical_layout : Optional[bool]
            This parameter is being deprecated.
        sort_by_position : Optional[bool]
            Specifies whether to sort the extracted text by positional coordinates or logical
            reading order.  If set to True, the text is sorted first by vertical position, and
            then by horizontal position.  If set to False (default), the logical reading order in
            the PDF is used.
        ocr : Optional[Literal["auto", "full"]]
            Specifies whether to use OCR to extract text from images in the PDF. If set to
            "auto", OCR is used only to extract text from images and integrate into the existing
            text. If set to "full", OCR is used to extract text from the entire PDF.
            To use this feature you must install Tesseract-OCR. For more information, see
            https://github.com/tesseract-ocr/tesseract#installing-tesseract.
        ocr_language : Optional[str]
            Specifies the language to use for OCR. The default language is English, which
            language code is `eng`.  For a list of supported languages and the respective codes
            access https://tesseract-ocr.github.io/tessdoc/Data-Files-in-different-versions.html.
            You can combine multiple languages by passing a string with the language codes
            separated by `+`. For example, to use English and German, pass `eng+deu`.
        multiprocessing : Optional[Union[bool, int]]
            We use multiprocessing to speed up PyMuPDF conversion, you can disable it by setting
            it to False.
            If set to None (the default value), the value defined in the class initialization is
            used.
            If set to True, the total number of cores is used. To specify the number of cores to
            use, set it to an integer.

        Returns
        -------
        List[Document]
            A Document with container elements extracted from PDF.

        """

        if remove_numeric_tables is None:
            remove_numeric_tables = self.remove_numeric_tables
        if valid_languages is None:
            valid_languages = self.valid_languages
        if id_hash_keys is None:
            id_hash_keys = self.id_hash_keys
        if multiprocessing is None:
            multiprocessing = self.multiprocessing
        if sort_by_position is None:
            sort_by_position = self.sort_by_position
        if ocr is None:
            ocr = self.ocr
        if ocr_language is None:
            ocr_language = self.ocr_language

        if encoding:
            warnings.warn(
                "The encoding parameter is being deprecated. It will be automatically detected "
                "by PyMuPDF.",
                DeprecationWarning,
            )

        if keep_physical_layout:
            warnings.warn(
                "The keep_physical_layout parameter is being deprecated.",
                DeprecationWarning,
            )

        if ocr is not None:
            if ocr not in ["auto", "full"]:
                raise ValueError("The ocr parameter must be either 'auto' or 'full'.")
            self._check_tessdata()

        pages = self._read_pdf(
            stream,
            sort_by_position=sort_by_position,
            start_page=start_page,
            end_page=end_page,
            ocr=ocr,
            ocr_language=ocr_language,
            multiprocessing=multiprocessing,
        )

        cleaned_pages = []
        for page in pages:
            lines = page.splitlines()
            cleaned_lines = []
            for line in lines:
                words = line.split()
                digits = [word for word in words if any(i.isdigit() for i in word)]

                # remove lines having > 40% of words as digits AND not ending with a period(.)
                if (
                    remove_numeric_tables
                    and words
                    and len(digits) / len(words) > 0.4
                    and not line.strip().endswith(".")
                ):
                    # TODO make this more informative for incoming bytestream
                    logger.debug("Removing line '%s' from %s", line, "stream")
                    continue
                cleaned_lines.append(line)

            page = "\n".join(cleaned_lines)
            cleaned_pages.append(page)

        if valid_languages:
            document_text = "".join(cleaned_pages)
            if not self.validate_language(document_text, valid_languages):
                # TODO make this more informative for incoming bytestream
                logger.warning(
                    "The language for %s is not one of %s. The file may not have "
                    "been decoded in the correct text format.",
                    "stream",
                    valid_languages,
                )

        text = "\f".join(cleaned_pages)
        document = Document(content=text, meta=meta, id_hash_keys=id_hash_keys)
        return [document]

    def _get_text_parallel(self, page_mp):
        idx, stream, parts, sort_by_position, ocr, ocr_language = page_mp

        doc = fitz.open(stream=stream, filetype="pdf")

        text_list = []
        for i in parts[idx]:
            page = doc[i]
            partial_tp = None
            if ocr is not None:
                full = ocr == "full"
                partial_tp = page.get_textpage_ocr(
                    flags=0, full=full, dpi=300, language=ocr_language
                )
            text_list.append(
                page.get_text("text", textpage=partial_tp, sort=sort_by_position)
            )
            text_list.append("\f")

        text = "".join(text_list)

        doc.close()

        return text

    def _read_pdf(
        self,
        stream: io.BytesIO,
        ocr_language: str,
        sort_by_position: bool = False,
        start_page: Optional[int] = None,
        end_page: Optional[int] = None,
        ocr: Optional[Literal["auto", "full"]] = None,
        multiprocessing: Optional[Union[bool, int]] = None,
    ) -> List[str]:
        """
        Extract pages from the pdf bytestream.

        Parameters
        ----------
        stream : io.BytesIO
            A bystream of a PDF file.
        ocr_language : str
            Specifies the language to use for optical character recognition.
            To combine multiple languages, pass a string with the language codes separated with
            a plus ("+").
            For example, to use English and German, pass eng+deu. Default: eng.
        sort_by_position : bool
            Specifies whether to sort the extracted text by positional coordinates or logical
            reading order.
            If set to True, the text is sorted first by vertical position, and then by horizontal
            position.
            If set to False (default), the logical reading order in the PDF is used.
        start_page : int
            The page number where to start the conversion, starting from 1.
        end_page : int
            The page number where to end the conversion.
        ocr : Optional[Literal["auto", "full"]]
            Specifies if optical character recognition (OCR) should be used to extract text from
            the images in the PDF.
            auto - Uses OCR only to extract text from images and integrate them into the existing
            text.
            full - Uses OCR to extract text from the entire PDF.
            Optional. Default: None.
        multiprocessing : Optional[Union[bool, int]
            We use multiprocessing to speed up PyMuPDF conversion, you can disable it by setting
            it to False.
            If set to None (the default value), the value defined in the class initialization is
            used.
            If set to True, the total number of cores is used. To specify the number of cores to
            use, set it to an integer.

        Returns
        -------
        str
            Text extracted from PDF document.

        """

        if start_page is None:
            start_page = 0
        else:
            start_page = start_page - 1

        doc = fitz.open(stream=stream, filetype="pdf")
        page_count = int(doc.page_count)

        if end_page is None or (end_page is not None and end_page > page_count):
            end_page = page_count

        document_list = []

        if not multiprocessing:
            for i in range(start_page, end_page):
                page = doc[i]
                partial_tp = None
                if ocr is not None:
                    full = ocr == "full"
                    partial_tp = page.get_textpage_ocr(
                        flags=0, full=full, dpi=300, language=ocr_language
                    )
                document_list.append(
                    page.get_text("text", textpage=partial_tp, sort=sort_by_position)
                )
                document_list.append("\f")
        else:
            cpu = cpu_count() if isinstance(multiprocessing, bool) else multiprocessing
            page_list = list(range(start_page, end_page))
            cpu = cpu if len(page_list) > cpu else len(page_list)
            parts = divide(cpu, page_list)
            pages_mp = [
                (i, stream, parts, sort_by_position, ocr, ocr_language)
                for i in range(cpu)
            ]

            with ProcessPoolExecutor(max_workers=cpu) as pool:
                results = pool.map(self._get_text_parallel, pages_mp)
                for page in results:
                    document_list.append(page)

        document = "".join(document_list)
        document = "\f" * start_page + document
        pages = document.split("\f")
        pages = pages[:-1]  # the last page in the split is always empty.

        doc.close()  # Close the document

        return pages


# Define a helper function to use haystack to extract text from a base64 encoded bytestram PDF
def haystack(
    pdf_stream, extract_text: bool, extract_images: bool, extract_tables: bool, **kwargs
):
    """
    Helper function to use haystack to extract text from a bytestream PDF.

    Parameters
    ----------
    pdf_stream : io.BytesIO
        A bytestream PDF.
    extract_text : bool
        Specifies whether or not to extract text.
    extract_images : bool
        Specifies whether or not to extract images.
    extract_tables : bool
        Specifies whether or not to extract tables.
    **kwargs
        The keyword arguments are used for additional extraction parameters.

    Returns
    -------
    str
        A string of extracted text.
    """

    logger.info("Extracting PDF with haystack backend.")

    converter = PDFtoTextConverterStream(
        remove_numeric_tables=True, valid_languages=["en"]
    )
    converted_pdf = converter.convert(stream=pdf_stream, meta=None)

    preprocessor = PreProcessor(
        clean_empty_lines=True,
        clean_whitespace=True,
        clean_header_footer=False,
        split_by="word",
        split_length=100,
        split_respect_sentence_boundary=True,
    )

    preprocessed_text = preprocessor.process(converted_pdf)

    text_list = []
    # Extract text from each element of partition response
    for document in preprocessed_text:
        text_list.append(document.content)

    text = "".join(text_list).replace("+", " ")

    return text
